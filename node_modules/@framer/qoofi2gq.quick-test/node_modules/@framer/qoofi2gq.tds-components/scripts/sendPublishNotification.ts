import { IncomingWebhook } from '@slack/webhook';
import * as fs from 'fs';

const LATEST_CHANGE_LOG_REGEX = /---((.|\n)*?)---/;

const SLACK_WEBHOOK_URL_FOR_CHANNEL_FRAMER_DEV =
  'https://hooks.slack.com/services/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';
const SLACK_WEBHOOK_URL_FOR_CHANNEL_FRAMER_CLOSEDBETA =
  'https://hooks.slack.com/services/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';

const webhookForFramerDev = new IncomingWebhook(SLACK_WEBHOOK_URL_FOR_CHANNEL_FRAMER_DEV);
const webhookForFramerClosedbeta = new IncomingWebhook(SLACK_WEBHOOK_URL_FOR_CHANNEL_FRAMER_CLOSEDBETA);
const webhooks = [webhookForFramerDev, webhookForFramerClosedbeta];

(async () => {
  fs.readFile(__dirname + '/../README.md', 'utf8', async (_, data: string) => {
    console.log(__dirname, data);
    const changeLog = data.match(LATEST_CHANGE_LOG_REGEX)?.[1];

    if (changeLog == null) {
      return;
    }

    await webhooks.forEach(webhook =>
      webhook.send({
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '*새 업데이트가 있습니다*',
            },
          },
          {
            type: 'divider',
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: changeLog,
            },
          },
        ],
      })
    );
  });
})();
