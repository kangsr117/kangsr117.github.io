import { useMemo, useEffect, useState } from "react";
import { throttle } from "lodash-es";

import { isIOS, isMobile } from "../../../utils/isMobile";
import isDevelopment from "../../../utils/isDevelopment";

import useViewport from "./useViewport";

declare const window: Window & {
  visualViewport?: {
    addEventListener: (event: string, func: () => void) => void;
    removeEventListener: (event: string, func: () => void) => void;
    height: number;
    offsetTop: number;
  };
};

/**
 * iOS에서 Fixed 요소의 경우 키보드가 올라와도 Fixed 상태를 유지하지 않는 문제에 대한 Fix
 */
export default function useBottomCTAStyle({
  isElementFixed,
}: {
  isElementFixed: boolean;
}) {
  const viewport = useViewport();

  const isTouching = useTouchingDetector();
  const isScrolling = useScrollingDetector();

  const potentialKeyboardRatio = useMemo(() => {
    if (!isMobile) {
      return 0;
    }

    if (isIOS) {
      const visibleHeight = viewport.height ?? window.innerHeight;
      const totalHeight = window.outerHeight ?? window.screen.availHeight;

      const potentialKeyboardHeight = totalHeight - visibleHeight;
      return potentialKeyboardHeight / totalHeight;
    } else {
      const totalHeight = screen.availHeight;
      const potentialKeyboardHeight = totalHeight - window.innerHeight;

      return potentialKeyboardHeight / totalHeight;
    }
  }, [viewport.height]);

  const isKeyboardOpen = useMemo(() => {
    if (typeof document === "undefined" || !isMobile || isDevelopment()) {
      return false;
    }

    // HACK(@raon0211):
    // 키보드의 열림 상태를 정확하게 감지할 방법이 없어서
    // (스크린 총 영역 - 보이는 영역)을 키보드의 높이로 생각하고,
    // 키보드가 차지하는 비율이 스크린 총 영역의 35%를 초과하면
    // 키보드가 열린 것으로 판단함.
    // NOTE(@raon0211):
    // document.activeElement로 focus된 요소가 있어도
    // 모바일 기기에서는 백 버튼 클릭이나 스크롤으로 blur 없이 키보드를 내릴 수 있음
    if (potentialKeyboardRatio > 0.35) {
      return true;
    } else {
      return false;
    }
  }, [potentialKeyboardRatio]);

  const bottomCTAStyle = useMemo(() => {
    if (!isIOS || !isElementFixed || !isKeyboardOpen) {
      return undefined;
    }

    // 스크롤 중이거나, 사용자 터치가 이루어지는 동안에는 BottomCTA를 숨긴다.
    // 숨기지 않으면 BottomCTA의 위치가 맞지 않아 어색해진다.
    if (isScrolling || isTouching) {
      return {
        opacity: 0,
      } as const;
    } else {
      // iOS에서 Fixed 요소가 이동한만큼 강제로 CTA 위치를 밀어올림
      return {
        bottom: `${-viewport.offsetY}px`,
      } as const;
    }
  }, [
    isElementFixed,
    isKeyboardOpen,
    isScrolling,
    isTouching,
    viewport.offsetY,
  ]);

  return { isBlock: isKeyboardOpen, style: bottomCTAStyle };
}

function useTouchingDetector() {
  const [isTouching, setIsTouching] = useState(false);

  useEffect(() => {
    let timeoutId: number | undefined;

    const handleTouchStart = () => {
      window.clearTimeout(timeoutId);

      timeoutId = window.setTimeout(() => {
        setIsTouching(true);
        timeoutId = undefined;
      }, 300);
    };

    const handleTouchEnd = () => {
      window.clearTimeout(timeoutId);

      timeoutId = window.setTimeout(() => {
        setIsTouching(false);
        timeoutId = undefined;
      }, 200);
    };

    window.addEventListener("touchstart", handleTouchStart, { passive: true });
    window.addEventListener("touchend", handleTouchEnd, { passive: true });

    return () => {
      window.removeEventListener("touchstart", handleTouchStart);
      window.removeEventListener("touchend", handleTouchEnd);
      window.clearTimeout(timeoutId);
    };
  }, []);

  return isTouching;
}

function useScrollingDetector() {
  const [isScrolling, setIsScrolling] = useState(false);

  useEffect(() => {
    let timeoutId: number | undefined = undefined;

    const scrollHandler = throttle(() => {
      setIsScrolling(true);

      window.clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => {
        setIsScrolling(false);
        timeoutId = undefined;
      }, 400);
    }, 50);

    window.addEventListener("scroll", scrollHandler, { passive: true });

    return () => {
      window.removeEventListener("scroll", scrollHandler);
      window.clearTimeout(timeoutId);
    };
  }, []);

  return isScrolling;
}
