import classnames from "classnames";
import * as React from "react";
import {
  Children,
  cloneElement,
  ComponentProps,
  ReactElement,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import { animated, useSpring } from "react-spring";
import useFocusChangeByKeyEvent from "../Tab/useFocusChangeByKeyEvent";
import TabItem from "./TabItem";

type TabItemElement = ReactElement<ComponentProps<typeof TabItem>>;

const FLUID_TAB_PADDING = 12;

export interface Props
  extends Omit<React.HTMLAttributes<HTMLDivElement>, "onChange"> {
  children: TabItemElement | TabItemElement[];

  /**
   * 탭들을 같은 너비로 보여주지 않고 유동적인 너비로 흐르게 보여주고 싶으면 이 prop을 `true`로 합니다.
   * fluid가 아닌 경우, TabItem은 4개까지만 사용하는 것이 권장됩니다.
   *
   * @default false
   */
  fluid?: boolean;

  /**
   * 탭이 바뀔 때 호출하는 이벤트입니다.
   */
  onChange: (index: number, key?: string | number) => void;
}

const Tab = ({
  className,
  fluid = false,
  onChange,
  children,
  ...rest
}: Props) => {
  const tabScrollWrapperRef = useRef<HTMLDivElement>(null);

  const selectedPropIndex = Children.toArray(children).findIndex(
    (child) => child.props.selected
  );
  const selectedIndex = selectedPropIndex === -1 ? 0 : selectedPropIndex;
  const tabLength = Children.count(children);

  const [indicatorWidth, setIndicatorWidth] = useState(0);
  const [firstItemOffsetLeft, setFirstItemOffsetLeft] = useState(0);
  const [indicatorTranslateX, setIndicatorTranslateX] = useState(0);

  const [focusedIndex, handleFocusChangeByKeyEvent] = useFocusChangeByKeyEvent(
    selectedIndex,
    tabLength,
    onChange
  );

  const handleWheel = useCallback(
    (event: React.WheelEvent<HTMLDivElement>) => {
      if (!fluid || tabScrollWrapperRef?.current == null) {
        return;
      }

      event.preventDefault();

      if (event.deltaY > 0) {
        tabScrollWrapperRef.current.scrollLeft += 20;
      } else {
        tabScrollWrapperRef.current.scrollLeft -= 20;
      }
    },
    [fluid]
  );

  useEffect(() => {
    if (!fluid || tabScrollWrapperRef.current == null) {
      return;
    }

    /** 선택된 탭이 View 밖에 걸쳐 있을 때 중앙에 오도록 스크롤 */
    const { scrollLeft, clientWidth } = tabScrollWrapperRef.current;

    if (indicatorTranslateX < scrollLeft) {
      tabScrollWrapperRef.current.scrollLeft =
        indicatorTranslateX -
        (clientWidth - indicatorWidth) / 2 +
        FLUID_TAB_PADDING;
      return;
    }

    const selectedTabRightOffset =
      indicatorTranslateX + indicatorWidth - (scrollLeft + clientWidth);

    if (selectedTabRightOffset > 0) {
      tabScrollWrapperRef.current.scrollLeft +=
        selectedTabRightOffset +
        (clientWidth - indicatorWidth) / 2 +
        FLUID_TAB_PADDING;
    }
  }, [fluid, indicatorTranslateX, indicatorWidth, selectedIndex, tabLength]);

  const spring = useSpring({
    width: indicatorWidth,
    translateX: indicatorTranslateX,
    config: {
      tension: 300,
      friction: 28,
      precision: 0.01,
    },
  });

  return (
    <div
      className={classnames(
        "tab",
        "has-hairline-after",
        { "tab--fluid": fluid },
        className
      )}
      style={{ background: "transparent" }}
      {...rest}
    >
      <div
        ref={tabScrollWrapperRef}
        className="tab__scroll-wrapper"
        onWheel={handleWheel}
      >
        <ul
          className="tab__list"
          role="tablist"
          onKeyDown={handleFocusChangeByKeyEvent}
        >
          {Children.map(children, (child, index) => {
            return cloneElement(child, {
              focused: index === focusedIndex,
              onClick: (event: React.MouseEvent<HTMLLIElement>) => {
                if (typeof child.props.onClick === "function") {
                  child.props.onClick(event);
                }
                onChange(index, child.props.key);
              },
              onSelectItem: (tabWidth: number, offsetLeft: number) => {
                setIndicatorWidth(tabWidth);
                setIndicatorTranslateX(offsetLeft - firstItemOffsetLeft);
              },
              onResize: (offsetLeft: number) => {
                if (index === 0) {
                  setFirstItemOffsetLeft(offsetLeft);
                }
              },
              style: { background: "transparent" },
            });
          })}
        </ul>
        <animated.div
          className="tab__indicator"
          style={{
            width: spring.width?.interpolate((v) => `${v}px`),
            transform: spring.translateX?.interpolate(
              (v) => `translateX(${v}px)`
            ),
          }}
        />
      </div>
    </div>
  );
};

export default Tab;

Tab.Item = TabItem;
