import Tippy, { TippyProps } from "@tippyjs/react/headless";
import * as React from "react";
import { cloneElement, MouseEvent, ReactElement, useState } from "react";
import { animated, useSpring } from "react-spring";

export interface BaseProps
  extends Omit<
    TippyProps,
    | "content"
    | "visible"
    | "offset"
    | "children"
    | "animation"
    | "onMount"
    | "onHide"
    | "render"
  > {
  message?: string | ReactElement;
  children?: ReactElement;
  open?: boolean;
  offset?: number;
  onChildrenClick?: (event: MouseEvent<HTMLElement>) => void;
}

function BaseTooltip({
  children,
  className,
  message,
  open = false,
  placement = "auto",
  offset = 10,
  onChildrenClick,
  ...rest
}: BaseProps) {
  const [spring, setSpring] = useSpring(() => {
    return {
      opacity: 0,
      transformOffset: 10,
      config: { tension: 400, friction: 40, precision: 0.1 },
    };
  });

  return (
    <Tippy
      {...rest}
      render={(attrs) => {
        return (
          <animated.div
            style={{
              opacity: spring.opacity,
              transform: spring.transformOffset?.interpolate((v) =>
                translateTemplate(attrs["data-placement"], v)
              ),
            }}
            className={`tooltip ${className}`}
            {...attrs}
          >
            {message}
            <div className="tooltip__arrow" data-popper-arrow="">
              <svg width="16px" height="8px" viewBox="0 0 200 100">
                <path d="M 0 0 L 200 0 L 100 100 Z" />
              </svg>
            </div>
          </animated.div>
        );
      }}
      placement={placement}
      visible={open}
      offset={[0, offset + 10]}
      animation={true}
      onMount={() => {
        setSpring({
          opacity: 1,
          transformOffset: 0,
        });
      }}
      onHide={() => {
        setSpring({
          opacity: 0,
          transformOffset: 10,
        });
      }}
    >
      {children != null ? (
        cloneElement(children, {
          ...children.props,
          onClick(event: MouseEvent<HTMLElement>) {
            children.props.onClick?.(event);
            onChildrenClick?.(event);
          },
        })
      ) : (
        <>{/* null로 하면 타입이 꼬여서 임의로 빈 Fragment를 넘깁니다 */}</>
      )}
    </Tippy>
  );
}

export type Props = Omit<BaseProps, "onChildrenClick">;

function UncontrolledTooltip(props: Props) {
  const [isOpened, setIsOpened] = useState(false);

  return (
    <BaseTooltip
      {...props}
      open={isOpened}
      onChildrenClick={() => {
        setIsOpened(true);
      }}
      onClickOutside={() => {
        setIsOpened(false);
      }}
    />
  );
}

function Tooltip({ open, ...restProps }: Props) {
  if (open !== undefined) {
    return <BaseTooltip open={open} {...restProps} />;
  } else {
    return <UncontrolledTooltip {...restProps} />;
  }
}

export default Tooltip;

function translateTemplate(placement: string | undefined, offset: number) {
  if (placement?.startsWith("top")) {
    return `translateY(${offset}px)`;
  }

  if (placement?.startsWith("bottom")) {
    return `translateY(-${offset}px)`;
  }

  if (placement?.startsWith("right")) {
    return `translateX(-${offset}px)`;
  }

  if (placement?.startsWith("left")) {
    return `translateX(-${offset}px)`;
  }

  return "";
}
