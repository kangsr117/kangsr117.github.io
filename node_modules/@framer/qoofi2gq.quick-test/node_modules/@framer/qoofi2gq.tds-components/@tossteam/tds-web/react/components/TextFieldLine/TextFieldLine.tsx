import classnames from "classnames";
import { defaultTo } from "lodash-es";
import * as React from "react";
import {
  forwardRef,
  Ref,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { WithRequiredKeys } from "../../utils/withRequiredKeys";

import generateID from "../../utils/generateID";
import useCombinedRefs from "../../utils/hooks/useCombinedRefs";
import { Context as FormGroupContext } from "../Form/FormGroup";
import { Icon } from "../Icon";

const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 100;

type HTMLProps = React.InputHTMLAttributes<HTMLInputElement>;

export interface Props extends Omit<HTMLProps, "placeholder"> {
  /**
   * input의 타입입니다.
   * numberPassword를 사용하시면, 키패드는 숫자이지만 텍스트를 비밀번호처럼 가리도록 설정할 수 있습니다.
   */
  type?: HTMLProps["type"] | "numberPassword";

  /**
   * 컴포넌트의 root element(`div`)에 추가되는 className입니다.
   */
  className?: string;

  label: string;

  /**
   * 에러 상태를 표시합니다.
   */
  hasError?: boolean;

  /**
   * 우측에 표시될 아이콘의 이름을 지정합니다.
   */
  rightIcon?: string;

  /**
   * 우측에 표시될 접미사를 지정합니다.
   */
  suffix?: string;

  /**
   * 입력값 옆에 조그맣게 표시될 subText를 지정합니다.
   */
  subText?: string;

  /**
   * 입력값이 있을 떄 label이 위로 이동하는 대신 보통 placeholder 처럼 동작하게 만듭니다.
   */
  hideLabel?: boolean;
}

const TextFieldLine = forwardRef(
  ({ value, ...props }: Props, ref: Ref<HTMLInputElement>) => {
    if (value === undefined) {
      return <UncontrolledTextFieldLine ref={ref} {...props} />;
    } else {
      return <ControlledTextFieldLine ref={ref} value={value} {...props} />;
    }
  }
);

const ControlledTextFieldLine = forwardRef(
  (
    {
      className,
      label,
      hasError,
      rightIcon,
      suffix,
      subText,
      value,
      style,
      hideLabel = false,
      ...inputProps
    }: WithRequiredKeys<Props, "value">,
    forwardedRef: Ref<HTMLInputElement>
  ) => {
    const uniqId = useMemo(() => generateID("text-field-line-"), []);
    const inputRef = useRef<HTMLInputElement>(null);
    const refCallback = useCombinedRefs<HTMLInputElement>(
      inputRef,
      forwardedRef
    );
    const ctxRef = useRef<CanvasRenderingContext2D>();

    useEffect(() => {
      if (subText == null || inputRef.current == null) {
        return;
      }

      const font = window.getComputedStyle(inputRef.current)?.font;
      const canvas = document.createElement("canvas");

      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;

      const ctx = canvas.getContext("2d");

      if (ctx == null) {
        return;
      }

      ctx.font = font;
      ctxRef.current = ctx;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const textWidth = useMemo(() => {
      if (ctxRef.current == null) {
        return;
      }

      const width = ctxRef.current.measureText(value?.toString() ?? label)
        .width;

      return `${Math.ceil(width)}px`;
    }, [value, label]);

    useEffect(() => {
      ctxRef.current?.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }, [textWidth]);

    const hasValue = useMemo(() => {
      return value.toString().length > 0;
    }, [value]);

    const handleClick = useCallback(() => {
      inputRef.current?.focus();
    }, []);

    const formGroupContext = useContext(FormGroupContext);

    const { isSecured, type } = useMemo(() => {
      if (inputProps.type === "numberPassword") {
        return {
          type: "tel",
          isSecured: true,
        };
      }
      return {
        type: inputProps.type,
        isSecured: false,
      };
    }, [inputProps.type]);

    return (
      <div
        className={classnames(
          "text-field-line",
          "font-size--22",
          { "form-control": formGroupContext.isInForm },
          { "text-field-line--has-value": hasValue },
          { "text-field-line--disabled": inputProps.disabled },
          {
            "text-field-line--error": defaultTo(
              hasError,
              formGroupContext.hasError
            ),
          },
          { "text-field-line--hide-label": hideLabel },
          className
        )}
        onClick={handleClick}
      >
        <input
          {...inputProps}
          ref={refCallback}
          id={uniqId}
          className={classnames("text-field-line__input", {
            "text-field-line__input--secured": isSecured,
          })}
          type={type}
          value={value}
          placeholder={label}
          style={{ ...style, width: textWidth }}
        />

        <div className="text-field-line__label font-size--13">
          <label htmlFor={uniqId}>{label}</label>
        </div>
        {subText !== undefined ? (
          <span className="text-field-line__sub-text">{subText}</span>
        ) : (
          <div className="text-field-line__space" />
        )}

        {rightIcon !== undefined ? (
          <Icon
            className="text-field-line__right-icon"
            name={rightIcon}
            size={24}
          />
        ) : null}

        {suffix !== undefined ? (
          <span className="text-field-line__suffix">{suffix}</span>
        ) : null}

        <span className="text-field-line__bottom-line" />
      </div>
    );
  }
);

const UncontrolledTextFieldLine = forwardRef(
  (props: Props, ref: Ref<HTMLInputElement>) => {
    const [value, setValue] = useState("");

    return (
      <ControlledTextFieldLine
        ref={ref}
        value={value}
        onChange={(event) => setValue(event.target.value)}
        {...props}
      />
    );
  }
);

export default TextFieldLine;
