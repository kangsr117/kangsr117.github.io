import {
  clearAllBodyScrollLocks,
  disableBodyScroll,
  enableBodyScroll,
} from "body-scroll-lock";
import classnames from "classnames";
import * as React from "react";
import {
  MouseEvent,
  ReactNode,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import { animated, useSpring } from "react-spring";
import { androidSafeAreaPatchCssClass } from "../../utils/hooks/useSafeAreaPatch";
import isSafeAreaExists from "../../utils/isSafeAreaExists";

export interface Props {
  children?: ReactNode;
  className?: string;

  /**
   * 화면에 Fixed 할지 여부를 결정합니다.
   * @default true;
   */
  fixed?: boolean;

  /** Controls whether or not the Modal is displayed. */
  open: boolean;

  /** Whether or not the Modal should close when the dimmer is clicked. */
  closeOnDimmerClick?: boolean;

  closeButton?: React.ReactNode;

  /** Callback fired when the modal has entered.
   * If the closing animation is started before the opening animation is finished, this callback
   * will be not called.
   */
  onEntered?: () => void;

  /** Callback fired when the modal has exited.
   * If the opening animation is started before the closing animation is finish, this callback wiil
   * be not called.
   */
  onExited?: () => void;

  /** Callback fired when the component requests to be closed. */
  onClose?: () => void;
}

export interface State {
  display: boolean;
}

function Modal({
  open,
  fixed = true,
  children,
  closeButton,
  className,
  closeOnDimmerClick = true,
  onClose,
  onEntered,
  onExited,
}: Props) {
  const [isDisplayed, setIsDisplayed] = useState(false);
  const contentRef = useRef<HTMLDivElement | null>(null);

  const handleDimmerClick = useCallback(
    (event: MouseEvent<HTMLDivElement>) => {
      if (event.target !== event.currentTarget) {
        return;
      }

      if (closeOnDimmerClick) {
        onClose?.();
      }
    },
    [closeOnDimmerClick, onClose]
  );

  useEffect(() => {
    if (contentRef.current == null) {
      return;
    }

    if (open && isDisplayed) {
      disableBodyScroll(contentRef.current);
    } else {
      enableBodyScroll(contentRef.current);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isDisplayed, open, contentRef.current]);

  useEffect(() => {
    if (!isSafeAreaExists()) {
      document.body.classList.add(androidSafeAreaPatchCssClass);
    }

    return () => {
      clearAllBodyScrollLocks();
    };
  }, []);

  useEffect(() => {
    if (isDisplayed) {
      onEntered?.();
    } else {
      onExited?.();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isDisplayed]);

  const spring = useSpring({
    opacity: open ? 1 : 0,
    scale: open ? 1 : 0.9,
    config: {
      tension: 400,
      friction: 40,
      precision: 0.01,
    },
    delay: 0.1,
    onFrame: ({ opacity: progress }: { opacity: number }) => {
      if ((open && progress > 0.95) || (!open && progress < 0.05)) {
        setIsDisplayed(open);
      }
    },
  });

  return (
    <div
      className={classnames("modal", {
        "modal--fixed": fixed,
      })}
      style={!isDisplayed && !open ? { display: "none" } : {}}
    >
      <animated.div
        className="dimmer modal__dimmer"
        style={{
          opacity: spring.opacity,
          pointerEvents: open && isDisplayed ? undefined : "none",
        }}
        onClick={handleDimmerClick}
      >
        <animated.div
          className={classnames("modal__card", className)}
          style={{
            transform: spring.scale?.interpolate((v) => `scale(${v})`),
          }}
          ref={contentRef}
        >
          {children}
        </animated.div>
        {closeButton}
      </animated.div>
    </div>
  );
}

export default Modal;
