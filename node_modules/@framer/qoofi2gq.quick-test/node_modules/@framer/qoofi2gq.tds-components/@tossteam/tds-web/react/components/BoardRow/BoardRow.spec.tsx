import * as React from 'react';
import { act, cleanup, fireEvent, render } from '@testing-library/react';

import { Props } from './BoardRow';

function renderBoardRow(props?: Partial<Props>, content?: React.ReactNode) {
  const propsWithDefault = {
    ...props,
    title: props !== undefined && props!.title !== undefined ? props.title : 'title',
  };

  // const fixture = render(<BoardRow {...propsWithDefault}>{content}</BoardRow>);
  const fixture = render(<div {...(propsWithDefault as any)}>{content}</div>);

  const queryPanel = () => fixture.container.querySelector('.board-row') as HTMLLIElement;

  const queryHeader = () => fixture.container.querySelector('.board-row__header') as HTMLElement;

  const queryContent = () => fixture.container.querySelector('.board-row__content') as HTMLElement;

  const isExpanded = () => queryPanel()!.classList.contains('board-row--expanded');
  const togglePanel = () =>
    act(() => {
      fireEvent.click(queryHeader()!);
    });

  const queryIndicator = () => queryHeader().querySelector('.svg-icon') as HTMLElement;

  return {
    ...fixture,
    queryPanel,
    queryHeader,
    queryContent,
    isExpanded,
    togglePanel,
    queryIndicator,
  };
}

// FIXME: circular dependency 문제로 임시로 빼둡니다.
// https://tossteam.slack.com/archives/C83Q0T5U1/p1573724061027700
describe.skip('BoardRow', () => {
  afterEach(cleanup);

  test('패널을 "initialOpened"로 초기에 열 수 있다.', () => {
    const { isExpanded } = renderBoardRow({ initialOpened: true });
    expect(isExpanded()).toBe(true);
  });

  test('패널을 "initialOpened"로 초기에 닫을 수 있다.', () => {
    const { isExpanded } = renderBoardRow({ initialOpened: false });
    expect(isExpanded()).toBe(false);
  });

  test('패널을 "isOpened"로 열 수 있다.', () => {
    const { isExpanded } = renderBoardRow({ isOpened: true });
    expect(isExpanded()).toBe(true);
  });

  test('패널을 "isOpened"로 닫을 수 있다.', () => {
    const { isExpanded } = renderBoardRow({ isOpened: false });
    expect(isExpanded()).toBe(false);
  });

  test('패널의 헤더를 클릭하여 패널을 열고/닫을 수 있다.', () => {
    const fixture = renderBoardRow();

    fixture.togglePanel();
    expect(fixture.isExpanded()).toBe(true);

    fixture.togglePanel();
    expect(fixture.isExpanded()).toBe(false);
  });

  test('패널이 열고 닫힐 때 이벤트를 발생시킬 수 있다.', () => {
    const onOpenedCallback = jest.fn();
    const onClosedCallback = jest.fn();
    const fixture = renderBoardRow({
      onOpen: onOpenedCallback,
      onClose: onClosedCallback,
    });

    fixture.togglePanel();
    expect(onOpenedCallback).toHaveBeenCalled();

    fixture.togglePanel();
    expect(onClosedCallback).toHaveBeenCalled();
  });

  test('패널이 열렸을 떄 헤더의 "aria-expanded" 값이 "true" 이다.', () => {
    let fixture = renderBoardRow({ initialOpened: true });
    expect(fixture.queryHeader()!.getAttribute('aria-expanded')).toBe('true');

    fixture.unmount();

    fixture = renderBoardRow({ initialOpened: false });
    expect(fixture.queryHeader()!.getAttribute('aria-expanded')).toBe('false');
  });

  test('각 패널의 헤더와 콘텐츠는 고유한 ID 값을 가져야 한다.', () => {
    const fixtureOne = renderBoardRow();
    const fixtureTwo = renderBoardRow();

    expect(fixtureOne.queryHeader()!.id).not.toEqual(fixtureTwo.queryHeader()!.id);
    expect(fixtureOne.queryContent()!.id).not.toEqual(fixtureTwo.queryHeader()!.id);
  });

  test('패널의 헤더는 role="button"이고 "aria-controls" 값이 콘텐츠의 ID 값이어야 한다.', () => {
    const { queryHeader, queryContent } = renderBoardRow();
    const headerEl = queryHeader()!;
    const contentEl = queryContent()!;

    expect(headerEl.getAttribute('role')).toEqual('button');
    expect(headerEl.getAttribute('aria-controls')).toEqual(contentEl.id);
  });

  test('패널의 콘텐츠 영역의 "aria-labelledby" 값은 헤더의 ID 값이어야 한다.', () => {
    const { queryHeader, queryContent } = renderBoardRow();
    const headerEl = queryHeader()!;
    const contentEl = queryContent()!;

    expect(contentEl.getAttribute('aria-labelledby')).toEqual(headerEl.id);
  });

  test('패널의 콘텐츠는 <section> 태그여야 한다.', () => {
    const fixture = renderBoardRow();

    expect(fixture.queryContent()!.tagName.toLowerCase()).toEqual('section');
  });

  test('지정한 "title" 값이 패널 헤더에, 자식 노드가 패널 콘텐츠에 표시된다.', () => {
    const fixture = renderBoardRow({ title: '타이틀입니다' }, <p>콘텐츠입니다</p>);

    expect(fixture.queryHeader().querySelector('.board-row__title')!.textContent).toContain(
      '타이틀입니다'
    );
    expect(fixture.queryContent().textContent).toContain('콘텐츠입니다');
  });

  test('"showQ" 값이 "true"이면 Q가 패널 헤더에 표시된다.', () => {
    const fixture = renderBoardRow({ showQ: true });

    expect(fixture.queryHeader().querySelector('.board-row__q')).not.toBeNull();
  });

  test('패널이 열려 있는 상태에서는 아이콘이 "arrow-downwards"이다.', () => {
    const { queryIndicator } = renderBoardRow({ isOpened: true });
    expect(queryIndicator().classList.contains('svg-icon--arrow-downwards')).toBe(true);
  });

  test('패널이 열려 있는 상태에서는 아이콘이 "arrow-rightwards"이다.', () => {
    const { queryIndicator } = renderBoardRow({ isOpened: false });
    expect(queryIndicator().classList.contains('svg-icon--arrow-rightwards')).toBe(true);
  });

  test('패널에 사용자 지정 CSS 클래스가 적용된다.', () => {
    const fixture = renderBoardRow({ className: 'MyCustomClass' });

    expect(fixture.queryPanel().classList.contains('MyCustomClass')).toBe(true);
  });

  test('헤더와 콘텐츠에 사용자 지정 ID 값을 적용할 수 있다.', () => {
    const fixture = renderBoardRow({
      headerId: 'my-unique-header',
      contentId: 'my-unique-content',
    });

    expect(fixture.queryHeader().id).toEqual('my-unique-header');
    expect(fixture.queryContent().id).toEqual('my-unique-content');
  });

  test('Props로 "isOpened"를 "true"로 설정한 경우 헤더를 클릭하여도 패널이 닫히지 않는다.', () => {
    const fixture = renderBoardRow({ isOpened: true });
    fixture.togglePanel();

    expect(fixture.isExpanded()).toBe(true);
  });

  test('Props로 "isOpened"를 "false"로 설정한 경우 헤더를 클릭하여도 패널이 열리지 않는다.', () => {
    const fixture = renderBoardRow({ isOpened: false });
    fixture.togglePanel();

    expect(fixture.isExpanded()).toBe(false);
  });
});
