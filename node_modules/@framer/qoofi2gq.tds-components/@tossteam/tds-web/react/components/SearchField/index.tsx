import { adaptive } from "@tossteam/colors";
import classnames from "classnames";
import * as React from "react";
import {
  forwardRef,
  memo,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import { PortalConsumer } from "../../providers/PortalContext";
import useCombinedRefs from "../../utils/hooks/useCombinedRefs";
import { Icon } from "../Icon";

interface Props extends React.InputHTMLAttributes<HTMLInputElement> {
  /**
   * 컴포넌트의 root element(`div`)에 추가되는 className입니다.
   */
  className?: string;
  /** 텍스트 삭제 아이콘을 눌렀을 때 불리는 콜백입니다. */
  onDeleteClick?: () => void;
  /**
   * 차지하는 공간만큼 빈 영역(space)을 렌더링합니다. 이 부분의 렌더링은 fixed 상태도 아니고 Portal도 사용하지 않습니다.
   * @default true
   */
  takeSpace?: boolean;
  /**
   * 상단 고정
   * @default false
   */
  fixed?: boolean;
}

const SearchField = forwardRef<HTMLInputElement, Props>(
  (props, forwardedRef) => {
    const {
      className,
      onChange,
      onDeleteClick,
      value = "",
      placeholder,
      fixed = true,
      takeSpace = true,
      name,
      ...restInputProps
    } = props;
    const [internalValue, setInternalValue] = useState(value);
    const [spaceHeight, setSpaceHeight] = useState(0);
    const inputRef = useRef<HTMLInputElement>(null);
    const refCallback = useCombinedRefs<HTMLInputElement>(
      inputRef,
      forwardedRef
    );

    useEffect(() => {
      setInternalValue(value);
    }, [value]);

    const handleChange: React.ChangeEventHandler<HTMLInputElement> = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        onChange?.(e);
        setInternalValue(e.target.value);
      },
      [onChange]
    );

    const handleWrapperClick = useCallback(() => {
      if (inputRef.current) {
        inputRef.current.click();
        inputRef.current.focus();
      }
    }, []);

    const handleDeleteClick = () => {
      onDeleteClick?.();
      changeEventDispatcher(inputRef);
    };

    const safeZone = <div style={{ height: spaceHeight }} />;

    const content = (
      <div
        className={classnames(
          "search-field",
          { "search-field--fixed": fixed },
          className
        )}
        ref={(element) => {
          if (element && takeSpace) {
            setSpaceHeight(element.clientHeight + 5);
          }
        }}
      >
        <div className="search-field__search" onClick={handleWrapperClick}>
          <Icon
            className="search-field__search-icon"
            name="searchfield"
            size={24}
            color={adaptive.grey600}
          />
          <input
            ref={refCallback}
            className="search-field__input"
            name={name}
            placeholder={placeholder}
            value={internalValue}
            type="text"
            onChange={handleChange}
            {...restInputProps}
          />
          <div
            className={classnames("search-field__delete", {
              "search-field__delete-hidden": !internalValue,
            })}
            onClick={handleDeleteClick}
          >
            <Icon
              className="search-field__delete-icon"
              name="delete"
              size={24}
              color={adaptive.grey400}
            />
          </div>
        </div>
        <div className="search-field__gradient" />
      </div>
    );

    if (fixed) {
      return (
        <>
          {safeZone}
          <PortalConsumer>{content}</PortalConsumer>
        </>
      );
    }

    return content;
  }
);

/**
 * 파라미터로 넘긴 inputRef의 onChange이벤트를 수동으로 dispatch 시킨다.
 * 참고: https://hustle.bizongo.in/simulate-react-on-change-on-controlled-components-baa336920e04
 * @param inputRef onChange 이벤트 주체
 */
const changeEventDispatcher = (inputRef: React.RefObject<HTMLInputElement>) => {
  const nativeInputValue = Object.getOwnPropertyDescriptor(
    window.HTMLInputElement.prototype,
    "value"
  );
  if (inputRef.current != null && nativeInputValue != null) {
    // 리액트가 native이벤트를 오버라이드하기 때문에 native input value setter를 inputRef와 함께 콜해야 한다. 이 로직이 없으면 dispatchEvent가 불리지 않는다
    nativeInputValue.set?.call(inputRef.current, ""); // e.target.value를 ''로 초기화;
    inputRef.current.dispatchEvent(new Event("input", { bubbles: true })); // bubbles: true 넘기지 않으면 dispatchEvent가 불리지 않는다
  }
};

export default memo(SearchField);
