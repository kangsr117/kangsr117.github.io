import Swiper from '@tossteam/swiper';
import { defaultTo, isEqual } from 'lodash-es';
import * as React from 'react';

import generateID from '../../utils/generateID';
import Pagination from './Pagination';
import Slide from './Slide';

export type PaginationPosition =
  | 'top-left'
  | 'top'
  | 'top-right'
  | 'bottom-left'
  | 'bottom'
  | 'bottom-right';

export type PaginationTheme = 'default' | 'light' | 'dark';
export interface AutoplayOption {
  /** Delay between transitions (in ms). If this parameter is not specified, auto play will be disabled */
  delay?: number;
  /** Enable this parameter and autoplay will be stopped when it reaches last slide (has no effect in loop mode) */
  stopOnLastSlide?: boolean;
  /**
   * Set to false and autoplay will not be disabled after user interactions (swipes), it will be
   * restarted every time after interaction
   *
   * - (default: `false`)
   */
  disableOnInteraction?: boolean;
  /** Enables autoplay in reverse direction */
  reverseDirection?: boolean;
  /** When enabled autoplay will wait for wrapper transition to continue. Can be disabled in case of using Virtual Translate when your slider may not have transition */
  waitForTransition?: boolean;
}

export interface Props {
  className?: string;
  children?: React.ReactNode;

  /** Index number of initial slide. */
  initialSlide?: number;

  /** Direction of slider. Could be 'horizontal' or 'vertical' (for vertical slider). */
  direction?: 'horizontal' | 'vertical';

  /** Set to **true** and slider wrapper will adopt its height to the height of the currently active slide */
  autoHeight?: boolean;

  /** 트랜지션 속도 */
  speed?: number;

  /** Object with autoplay parameters or boolean true to enable with default settings. */
  autoplay?: boolean | AutoplayOption;

  /** Distance between slides in px. */
  spaceBetween?: number;

  /** Number of slides per view (slides visible at the same time on slider's container).
   * If you use it with "auto" value and along with loop: true then you need to specify
   * loopedSlides parameter with amount of slides to loop (duplicate) slidesPerView: 'auto' is
   * currently not compatible with multirow mode, when slidesPerColumn > 1
   */
  slidesPerView?: number | 'auto';

  /** If true, then active slide will be centered, not always on the left side. */
  centeredSlides?: boolean;

  /** Add (in px) additional slide offset in the beginning of the container (before all slides) */
  slidesOffsetBefore?: number;

  /** Add (in px) additional slide offset in the end of the container (after all slides) */
  slidesOffsetAfter?: number;

  /**
   * If true then slides will not have fixed positions
   *
   * - (default: `false`)
   */
  freeMode?: boolean;

  /**
   * Set to true to enable snap to slides positions in free mode
   *
   * - (default: `false`)
   */
  freeModeSticky?: boolean;

  /** Set to true to enable continuous loop mode.
   * !**Warning**!: Loop mode does not work properly with the react component because it clones
   * slides. The cloned slides are just dom element not react component.
   */
  loop?: boolean;

  /** Show the default pagination */
  embeddedPagination?: boolean;

  /** Position of embedded pagination */
  paginationPosition?: PaginationPosition;

  /**
   * @deprecated since version 2.12.0
   *
   * Please use `paginationVerticalMarginFromEdge` instead.
   */
  paginationMarginFromEdge?: number;

  /**
   * Margin between pagination and top or bottom edge of slider.
   */
  paginationVerticalMarginFromEdge?: number;

  /**
   * Margin between pagination and top or bottom edge of slider.
   *
   * Only effect when `paginationPosition` is '*-left' or '*-right'
   */
  paginationHorizontalMarginFromEdge?: number;

  paginationTheme?: PaginationTheme;

  /** Event will be fired when currently active slide is changed */
  onSlideChange?: (currentIndex: number, isAutoplay: boolean) => void;

  /**
   * @default false
   */
  emitSlideChangeOnInit?: boolean;

  /**
   * Set to true to enable Mutation Observer on Swiper and its elements. In this case Swiper will be updated
   * (reinitialized) each time if you change its style (like hide/show) or modify its child elements
   * (like adding/removing slides)
   *
   * @default false
   */
  observer?: boolean;

  /**
   * Set to true if you also need to watch Mutations for Swiper parent elements.
   * @default false
   */
  observeParents?: boolean;

  // TODO: Add jsdocs.
  touchStart?: () => void;
  touchMove?: () => void;
  touchEnd?: () => void;
  transitionStart?: () => void;
  transitionEnd?: () => void;
}

/**
 * Dom7 인터페이스의 일부분 입니다.
 * 참고: https://github.com/nolimits4web/dom7/blob/master/dist/dom7.d.ts
 */
interface Dom7Instance {
  length: number;
  [index: number]: Element;
}

interface SwiperInstance {
  slideTo(index: number): void;
  update(): void;
  destroy(): void;

  autoplay: {
    start(): void;
    stop(): void;
  };

  pagination: {
    readonly bullets: Dom7Instance;
    render(): void;
    update(): void;
  };

  readonly realIndex: number;
}

export default class Carousel extends React.Component<Props> {
  public static Slide = Slide;
  public static Pagination = Pagination;

  public state: {
    uniqId?: string;
  } = {
    uniqId: undefined,
  };

  private swiper?: SwiperInstance;
  private isTouchMoveEventFiredBeforeSlideChange: boolean;

  public constructor(props: Props) {
    super(props);
    this.isTouchMoveEventFiredBeforeSlideChange = false;
  }

  public componentDidMount() {
    this.setState({ uniqId: generateID('slider-') }, () => this.initializeSwiper());
  }

  public componentDidUpdate(prevProps: Readonly<Props>) {
    if (this.doesNeedsUpdateSwiper(prevProps)) {
      this.updateSwiper();
    }
  }

  public componentWillUnmount() {
    if (this.swiper !== undefined) {
      this.swiper.destroy();
    }
  }

  public render() {
    const props = this.props;
    const embeddedPagination = props.embeddedPagination === undefined || props.embeddedPagination;
    const verticalMarginFromEdge = defaultTo(
      props.paginationVerticalMarginFromEdge,
      defaultTo(props.paginationMarginFromEdge, 16)
    );
    const horizontalMarginFromEdge = defaultTo(props.paginationHorizontalMarginFromEdge, 20);

    return (
      <div id={this.state.uniqId} className={`swiper-container ${defaultTo(props.className, '')}`}>
        <div className="swiper-wrapper">{props.children}</div>
        {embeddedPagination ? (
          <Pagination
            position={defaultTo(props.paginationPosition, 'bottom')}
            verticalMarginFromEdge={verticalMarginFromEdge}
            horizontalMarginFromEdge={horizontalMarginFromEdge}
            paginationTheme={defaultTo(props.paginationTheme, 'default')}
          />
        ) : (
          ''
        )}
      </div>
    );
  }

  public slideTo(index: number) {
    if (this.swiper != null) {
      this.swiper.slideTo(index);
    }
  }

  public startAutoplay() {
    if (this.swiper != null) {
      this.swiper.autoplay.start();
    }
  }

  public stopAutoplay() {
    if (this.swiper != null) {
      this.swiper.autoplay.stop();
    }
  }

  private initializeSwiper = () => {
    const props = this.props;
    let autoplayOption = props.autoplay;
    if (props.autoplay !== undefined && typeof props.autoplay !== 'boolean') {
      autoplayOption = {
        delay: props.autoplay.delay,
        stopOnLastSlide: props.autoplay.stopOnLastSlide,
        reverseDirection: props.autoplay.reverseDirection,
        waitForTransition: props.autoplay.waitForTransition,

        disableOnInteraction: false,
      };
    }

    const component = this;
    const configs = {
      speed: props.speed,
      direction: props.direction,
      initialSlide: props.initialSlide,
      autoHeight: props.autoHeight,
      autoplay: autoplayOption,
      spaceBetween: props.spaceBetween,
      slidesPerView: props.slidesPerView,
      centeredSlides: props.centeredSlides,
      slidesOffsetBefore: props.slidesOffsetBefore,
      slidesOffsetAfter: props.slidesOffsetAfter,
      freeMode: props.freeMode,
      freeModeSticky: props.freeModeSticky,
      loop: props.loop,
      observer: props.observer,
      observeParents: props.observeParents,

      pagination: {
        el: `#${this.state.uniqId} .swiper-pagination`,
        dynamicBullets: this.doesUseDynamicBullets(),
        dynamicMainBullets: 2,
      },

      on: {
        init: function onInit(this: SwiperInstance) {
          // loop 모드인 경우 Swiper 초기화시에 'onSlideChange'가 바로 호출되므로 무시합니다.
          if (props.emitSlideChangeOnInit && !props.loop) {
            component.emitSlideChange(this.realIndex);
          }
        },
        touchStart: () => {
          if (this.swiper != null) {
            this.swiper.autoplay.stop();
          }

          if (this.props.touchStart !== undefined) {
            this.props.touchStart();
          }
        },
        touchMove: () => {
          this.isTouchMoveEventFiredBeforeSlideChange = true;
          if (this.props.touchMove !== undefined) {
            this.props.touchMove();
          }
        },
        touchEnd: () => {
          if (
            (typeof props.autoplay === 'boolean' && props.autoplay) ||
            (typeof props.autoplay === 'object' &&
              !defaultTo(props.autoplay.disableOnInteraction, false))
          ) {
            if (this.swiper != null) {
              this.swiper.autoplay.start();
            }
          }
          if (this.props.touchEnd !== undefined) {
            this.props.touchEnd();
          }
        },
        transitionStart: () => {
          this.isTouchMoveEventFiredBeforeSlideChange = false;
          if (this.props.transitionStart !== undefined) {
            this.props.transitionStart();
          }
        },
        transitionEnd: () => {
          if (this.props.transitionEnd !== undefined) {
            this.props.transitionEnd();
          }
        },
        slideChange: function(this: SwiperInstance) {
          component.emitSlideChange(this.realIndex);
        },
        observerUpdate: function(this: SwiperInstance) {
          // Safari에서 loop 모드인 경우 pagination이 정상적으로 나타나지 않는 문제가 있습니다.
          // Carousel Dom에 변경이 있었을때, pagination bullet 개수가 0인 경우 새롭게 pagination을 그립니다.
          if (this.pagination.bullets.length === 0) {
            this.pagination.render();
            this.pagination.update();
          }
        },
      },
    };

    // Delete undefined properties.
    Object.keys(configs).forEach(key => {
      if ((configs as any)[key] == null) {
        delete (configs as any)[key];
      }
    });

    this.swiper = new Swiper(`#${this.state.uniqId}`, configs);
  };

  private doesNeedsUpdateSwiper = (prevProps: Readonly<Props>) => {
    const prevKeys = this.getKeysFromChildren(prevProps.children);
    const currentKeys = this.getKeysFromChildren(this.props.children);
    return !isEqual(prevKeys, currentKeys);
  };

  private getKeysFromChildren = (children?: React.ReactNode) => {
    if (children === undefined || children === null) {
      return [];
    }

    return React.Children.map(children, child => {
      if (child === undefined || child === null) {
        return undefined;
      }

      // Cast child to any to access private property of child.
      return (child as any).key as React.Key;
    });
  };

  private updateSwiper() {
    if (!this.swiper) {
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line
        console.error('Slider: swiper.update() before swiper initialized.');
      }
      return;
    }

    this.swiper.update();
  }

  private doesUseDynamicBullets() {
    // TODO: Count only if child is slide component.
    return React.Children.toArray(this.props.children).length >= 5;
  }

  private emitSlideChange = (activeIndex: number) => {
    if (typeof this.props.onSlideChange === 'function') {
      this.props.onSlideChange(activeIndex, !this.isTouchMoveEventFiredBeforeSlideChange);
    }
  };
}
