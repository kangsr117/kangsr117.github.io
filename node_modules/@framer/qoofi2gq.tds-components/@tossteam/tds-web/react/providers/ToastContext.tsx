import * as React from "react";
import {
  ComponentProps,
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { Toast } from "..";

interface ToastOptions
  extends Pick<
    ComponentProps<typeof Toast>,
    "icon" | "text" | "button" | "higherThanCTA"
  > {}

const ToastContext = createContext<{
  openToast: (options: ToastOptions) => void;
}>({
  openToast: () => {},
});

let closeResolver: (() => void) | undefined;

export function ToastProvider({ children }: { children: ReactNode }) {
  const timeoutId = useRef<number | null>(null);
  const [options, setOptions] = useState<ToastOptions>({ text: "" });
  const [isOpen, setIsOpen] = useState(false);

  // isOpen 여부에 따라 아래 open 함수에서 동작이 달라지는데,
  // isOpen이 state라서 isOpen에 따라 open 함수의 reference가 계속 달라짐.
  // open함수의 reference가 달라지는 문제를 방지하기 위해 useRef 사용
  const isOpenRef = useRef(isOpen);
  useEffect(() => {
    isOpenRef.current = isOpen;
  });

  const open = useCallback(async (options: ToastOptions) => {
    function waitForClose() {
      return new Promise((resolve) => {
        closeResolver = resolve;
      });
    }

    if (isOpenRef.current) {
      setIsOpen(false);
      await waitForClose();
    }

    setOptions(options);
    setIsOpen(true);
  }, []);

  useEffect(() => {
    function clearTimeout() {
      if (timeoutId.current != null) {
        window.clearTimeout(timeoutId.current);
        timeoutId.current = null;
      }
    }

    if (!isOpen) {
      return clearTimeout;
    }

    timeoutId.current = window.setTimeout(
      () => {
        setIsOpen(false);
      },
      options.button === undefined ? 3000 : 5000
    );

    return clearTimeout;
  }, [isOpen, options.button]);

  const controls = useMemo(() => {
    return {
      openToast: open,
    };
  }, [open]);

  return (
    <ToastContext.Provider value={controls}>
      {children}
      <Toast {...options} open={isOpen} onExited={closeResolver} />
    </ToastContext.Provider>
  );
}

export function useToast() {
  const controls = useContext(ToastContext);

  if (controls == null) {
    throw new Error("ToastContext 안에서 사용해주세요");
  }

  return controls;
}
