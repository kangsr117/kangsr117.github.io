import { addPropertyControls, ControlType } from 'framer';
import * as React from 'react';
import { ComponentProps, useEffect, useState } from 'react';
import { default as TDSAgreement } from '../@tossteam/tds-web/react/components/NewAgreement';
import { TDSComponent } from '../src/components/TDSComponent';
import { useFilteringEventHandlersInInspector } from '../src/hooks/useFilteringEventHandlersInInspector';
import { useUncontrolled } from '../src/hooks/useUncontrolled';
import '../src/styles/tds-framer.css';
import { isStaticRenderTarget } from '../src/utils/isStaticRenderTarget';
import { makeComponentDisplayName } from '../src/utils/makeDisplayName';

const typeLabels = ['Big', 'Medium', 'Small'] as const;

type TypeLabel = typeof typeLabels[number];

const componentByTypeLabel: Record<TypeLabel, JSX.Element> = {
  Big: <TDSAgreement.RowBig />,
  Medium: <TDSAgreement.RowMedium />,
  Small: <TDSAgreement.RowSmall />,
};

const componentTypeNameByTypeLabel: Record<TypeLabel, string> = {
  Big: 'AgreementRowBig',
  Medium: 'AgreementRowMedium',
  Small: 'AgreementRowSmall',
};

const childComponentByTypeLabel: Record<TypeLabel, JSX.Element | null> = {
  Big: <TDSAgreement.RowMedium />,
  Medium: <TDSAgreement.RowSmall />,
  Small: null,
};

const childrenComponentTypeNameByTypeLabel: Record<TypeLabel, string | undefined> = {
  Big: 'AgreementRowMedium',
  Medium: 'AgreementRowSmall',
  Small: undefined,
};

interface Props {
  type: TypeLabel;
  text: string;
  withUnderline: boolean;
  indentationLevel: 0 | 1 | 2;

  withCheckbox: boolean;
  checked: boolean;

  withArrow: boolean;
  withBorder: boolean;

  withSubAgreement: boolean;
  isSubAgreementOpen: boolean;
  subAgreementWithCheckbox: boolean;
  subAgreementChecked: boolean;
  subAgreements: string[];

  onAllChecked?: () => void;
  onNotAllChecked?: () => void;
}

export function AgreementV2(props: Props) {
  const {
    type,
    text,
    withUnderline,
    indentationLevel,

    withCheckbox,
    checked,

    withArrow,
    withBorder,

    withSubAgreement,
    isSubAgreementOpen,
    subAgreementWithCheckbox,
    subAgreementChecked,
    subAgreements,

    onAllChecked,
    onNotAllChecked,
  } = useFilteringEventHandlersInInspector(props);

  // TODO: refactor agreement checkbox logis into a hook function
  const [subAgreementRows, setSubAgreementRows] = useState<
    { text: string; checked: boolean; onChange: (checked: boolean) => void }[]
  >([]);
  useEffect(() => {
    setSubAgreementRows(
      withSubAgreement
        ? subAgreements.map((text, index) => ({
            text,
            checked: withCheckbox ? checked : subAgreementChecked,
            onChange: checked =>
              setSubAgreementRows(rows => [
                ...rows.slice(0, index),
                {
                  ...rows[index],
                  checked,
                },
                ...rows.slice(index + 1),
              ]),
          }))
        : []
    );
  }, [withSubAgreement, subAgreements]);

  const doesSubAgreementExist = type !== 'Small' && withSubAgreement && subAgreementRows.length > 0;
  const isAllChecked =
    doesSubAgreementExist && type === 'Big' ? subAgreementRows.every(({ checked }) => checked) : checked;

  const { value: checkedValue, handleChange: handleCheckedChange } = useUncontrolled(isAllChecked);

  useEffect(() => {
    if (isStaticRenderTarget() || !doesSubAgreementExist) {
      return;
    }

    if (checkedValue !== isAllChecked) {
      handleCheckedChange(isAllChecked);
      if (isAllChecked) {
        onAllChecked?.();
      } else {
        onNotAllChecked?.();
      }
    }
  }, [subAgreementRows]);

  const component = componentByTypeLabel[type];
  const childComponent = childComponentByTypeLabel[type];

  const componentProps: ComponentProps<typeof TDSAgreement.RowBig> = {
    ...component.props,
    checked: checkedValue,
    onCheckedChange: (_, newValue) => {
      if (!doesSubAgreementExist) {
        handleCheckedChange(newValue);
        return;
      }
      subAgreementRows.forEach(({ onChange }) => onChange(newValue));
    },
    withBorder: type === 'Big' && withBorder,
    withCheckbox: type !== 'Small' && withCheckbox,
    withArrow: type !== 'Small' && withArrow,
    underline: withUnderline,
    defaultCollapsed: !isSubAgreementOpen,
  };
  const childrenNode = [
    text,
    doesSubAgreementExist ? (
      <TDSAgreement>
        {subAgreementRows.map(({ text, checked, onChange }) =>
          React.cloneElement(
            childComponent,
            {
              checked,
              onCheckedChange: (_, newValue) => onChange(newValue),
              withArrow: type === 'Big',
              withCheckbox: type === 'Big' && subAgreementWithCheckbox,
            },
            text
          )
        )}
      </TDSAgreement>
    ) : null,
  ];

  return (
    <TDSComponent
      name={component.type.name}
      summary={{
        type: componentTypeNameByTypeLabel[type],
        text,
        checked: type !== 'Small' && withCheckbox ? checked : undefined,
        checkbox: type !== 'Small' ? withCheckbox : undefined,
        border: type === 'Big' ? withBorder : undefined,
        underline: type === 'Small' ? withUnderline : undefined,
        subAgreements: doesSubAgreementExist
          ? {
              items: subAgreements,
              withCheckbox: subAgreementWithCheckbox ? subAgreementWithCheckbox : undefined,
              checked: subAgreementWithCheckbox ? subAgreementChecked : undefined,
            }
          : undefined,
      }}
    >
      <TDSAgreement>{React.cloneElement(component, componentProps, childrenNode)}</TDSAgreement>
    </TDSComponent>
  );
}

addPropertyControls(AgreementV2, {
  type: {
    title: 'ğŸš¥ ì¢…ë¥˜',
    type: ControlType.Enum,
    displaySegmentedControl: true,
    options: typeLabels as any,
    defaultValue: typeLabels[2],
  },
  text: {
    title: 'âœï¸ í…ìŠ¤íŠ¸',
    type: ControlType.String,
    defaultValue: 'í† ìŠ¤ì¦ê¶Œ í•„ìˆ˜ ì•½ê´€ ì „ì²´ ë™ì˜',
    hidden(props) {
      return props.type === 'Small';
    },
  },
  withUnderline: {
    title: 'â†³ ë°‘ì¤„',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: false,
    hidden(props) {
      return props.type !== 'Small';
    },
  },

  withCheckbox: {
    title: 'â˜‘ï¸ ì²´í¬',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: true,
    hidden(props) {
      return props.type === 'Small';
    },
  },
  checked: {
    title: 'ã€€ â†³ ì²´í¬',
    type: ControlType.Boolean,
    enabledTitle: 'ON',
    disabledTitle: 'OFF',
    defaultValue: false,
    hidden(props) {
      return props.type === 'Small' || !props.withCheckbox;
    },
  },

  withArrow: {
    title: 'â¡ï¸ í™”ì‚´í‘œ',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: true,
    hidden(props) {
      return props.type === 'Small';
    },
  },
  indentationLevel: {
    title: 'ğŸ“ ë“¤ì—¬ì“°ê¸°',
    type: ControlType.Enum,
    displaySegmentedControl: true,
    options: [0, 1, 2],
    optionTitles: ['ì—†ìŒ', 'ğŸš§1ë‹¨ê³„', 'ğŸš§2ë‹¨ê³„'],
    defaultValue: 0,
  },
  withBorder: {
    title: 'ğŸ“ ë³´ë”',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: true,
    hidden(props) {
      return props.type !== 'Big';
    },
  },

  withSubAgreement: {
    title: 'ğŸ‘©â€ğŸ‘§â€ğŸ‘§ í•˜ìœ„ì•½ê´€',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: false,
    hidden(props) {
      return props.type === 'Small';
    },
  },
  isSubAgreementOpen: {
    title: 'ã€€ â†³ í¼ì¹¨',
    type: ControlType.Boolean,
    enabledTitle: 'í¼ì¹˜ê¸°',
    disabledTitle: 'ì ‘ê¸°',
    defaultValue: true,
    hidden(props) {
      return props.type !== 'Big' || !props.withSubAgreement;
    },
  },
  subAgreementWithCheckbox: {
    title: 'ã€€ â†³ ì²´í¬',
    type: ControlType.Boolean,
    enabledTitle: 'ìˆìŒ',
    disabledTitle: 'ì—†ìŒ',
    defaultValue: true,
    hidden(props) {
      return props.type !== 'Big' || !props.withSubAgreement;
    },
  },
  subAgreementChecked: {
    title: 'ã€€ â†³ ìƒíƒœ',
    type: ControlType.Boolean,
    enabledTitle: 'ON',
    disabledTitle: 'OFF',
    defaultValue: true,
    hidden(props) {
      return props.type !== 'Big' || !props.withSubAgreement || !!props.withCheckbox;
    },
  },
  subAgreements: {
    title: 'í•˜ìœ„ì•½ê´€',
    type: ControlType.Array,
    propertyControl: {
      type: ControlType.String,
    },
    defaultValue: ['ì¢…í•© ê³„ì¢Œ ì•½ê´€', 'ì „ìê¸ˆìœµê±°ë˜ ì´ìš©ì•½ê´€', 'ì œíœ´ì‚¬ ì‹ ìš©ì •ë³´ ì¡°íšŒ ë™ì˜ (ì„ íƒ)'],
    hidden(props) {
      return !props.withSubAgreement;
    },
  },

  onAllChecked: {
    type: ControlType.EventHandler,
  },
  onNotAllChecked: {
    type: ControlType.EventHandler,
  },
});

(AgreementV2 as any).defaultProps = {
  width: 375,
  height: 195,
  subAgreements: ['ì¢…í•© ê³„ì¢Œ ì•½ê´€', 'ì „ìê¸ˆìœµê±°ë˜ ì´ìš©ì•½ê´€', 'ì œíœ´ì‚¬ ì‹ ìš©ì •ë³´ ì¡°íšŒ ë™ì˜ (ì„ íƒ)'],
};

AgreementV2.displayName = makeComponentDisplayName('Agreement', 'ì•½ê´€');
