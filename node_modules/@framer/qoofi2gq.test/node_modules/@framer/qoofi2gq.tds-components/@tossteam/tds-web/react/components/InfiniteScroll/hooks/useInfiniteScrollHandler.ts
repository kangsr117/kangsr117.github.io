import { useCallback, useState, UIEvent } from 'react';

const noop = () => {};

export type ScrollDirection = 'top' | 'bottom';

interface ScrollPosition {
  scrollHeight: number;
  scrollTop: number;
  clientHeight: number;
}

function eventToScrollPosition(event: UIEvent<any>): ScrollPosition {
  const target = event.target as HTMLElement;

  const scrollHeight = target.scrollHeight;
  const scrollTop = target.scrollTop;
  const clientHeight = target.clientHeight;

  return { scrollHeight, scrollTop, clientHeight };
}

function isScrollingTo(
  positions: ScrollPosition[],
  threshold: number
): { direction: ScrollDirection; scrolled: boolean } | null {
  const [prevPosition, nextPosition] = positions;
  const { scrollHeight, scrollTop, clientHeight } = nextPosition;

  if (prevPosition.scrollTop < scrollTop) {
    return {
      direction: 'bottom',
      scrolled: scrollHeight - (scrollTop + clientHeight) <= threshold,
    };
  } else if (prevPosition.scrollTop > scrollTop) {
    return {
      direction: 'top',
      scrolled: scrollTop <= threshold,
    };
  }

  return null;
}

interface Options {
  threshold: number;
  onScroll?: (direction: ScrollDirection) => void;
}

export default function useInfiniteScrollHandler({ threshold, onScroll = noop }: Options) {
  const [, setPrevPosition] = useState<ScrollPosition>();

  return useCallback(
    (event: UIEvent<any>) => {
      const nextPosition = eventToScrollPosition(event);

      setPrevPosition(position => {
        if (position === undefined) {
          return nextPosition;
        }

        const result = isScrollingTo([position, nextPosition], threshold);

        if (result !== null && result.scrolled) {
          onScroll(result.direction);
        }

        return nextPosition;
      });
    },
    [threshold, onScroll]
  );
}
