import classnames from "classnames";
import * as React from "react";
import { ComponentProps, useMemo } from "react";
import { useKeyframesAnimation } from "../../utils/keyframes";
import Icon from "../Icon/Icon";

interface ImageItem {
  type: "image";
  src: string;
  srcSet?: string;
  /**
   * NOTE(@seokju-na):
   *  <img />는 이미지가 로드되기 전까지 이미지 크기를 구할 수 없어서 수동으로 크기를 지정합니다. 추후에 자동으로 크기를
   *  계산하는 로직이 만들어진다면 이 프로퍼티를 옵셔널로 처리할 수 있습니다.
   */
  width: number;
  /** @default <LogoSlide />에서 지정한 height */
  height?: number;
  alt?: string;
}

interface IconItem
  extends Pick<ComponentProps<typeof Icon>, "name" | "color" | "alt"> {
  type: "icon";
}

type Item = ImageItem | IconItem;
type ItemKeyTrackFn = (item: Item) => string | number;

const defaultImageKeyTrackFn: ItemKeyTrackFn = (item: Item) => {
  if (item.type === "image") {
    return item.src;
  }

  return item.name;
};

interface Props {
  items: Item[];
  /** @default 이미지의 주소 혹은 아이콘 이름을 key로 사용합니다. */
  keyTrackFn?: ItemKeyTrackFn;
  /** @default 280 */
  width?: number;
  /** @default 40 */
  height?: number;
  /** @default 20 */
  spacing?: number;
  /**
   * 슬라이드가 한 사이클 도는데 걸리는 시간.
   * @default 5000 (5초)
   */
  duration?: number;
  /** 애니메이션 시작전 딜레이 */
  delay?: number;
  ariaLabel?: string;
  className?: string;
}

/**
 * 복수개의 이미지나 tds icon이 옆으로 흘러가는 infinite 애니메이션 컴포넌트 입니다.
 */
export default function LogoSlide({
  items,
  keyTrackFn = defaultImageKeyTrackFn,
  width = 280,
  height = 40,
  spacing = 20,
  delay,
  duration = 5000,
  ariaLabel,
  className,
}: Props) {
  const totalWidth = useMemo(() => getTotalWidth(items, spacing, height), [
    items,
    spacing,
    height,
  ]);
  const multiplyCount = 1 + Math.ceil(width / totalWidth);

  const ref = useKeyframesAnimation<HTMLUListElement>(
    [
      {
        offset: "from",
        css: {
          transform: "translateX(0)",
        },
      },
      {
        offset: "to",
        css: {
          transform: `translateX(-${totalWidth}px)`,
        },
      },
    ],
    {
      duration,
      delay,
    }
  );

  return (
    <div
      className={classnames("logo-slide", className)}
      style={{
        width: `${width}px`,
        height: `${height}px`,
      }}
    >
      {/**
       * NOTE(@seokju-na):
       *  iOS에서 간혹 오차가 생겨 1px 크기 정도의 세로선이 생기는 경우가 있습니다. 이를 해결하기 위해 원래 크기보다 1px 작게 마스크 크기를 설정합니다.
       *  밑에 "logo-slide__mask--right" 부분도 동일하게 참고 부탁드립니다.
       *  @see https://tossteam.slack.com/archives/C7N78EM2Q/p1577787977108500
       */}
      <div
        className="logo-slide__mask logo-slide__mask--left"
        style={{ width: `${height - 1}px` }}
      />
      <ul
        ref={ref}
        aria-label={ariaLabel}
        className="logo-slide__carousel"
        style={{
          width: `${totalWidth * multiplyCount}px`,
        }}
      >
        {multiplyItems(items, multiplyCount).map(({ no, item }) => (
          <li
            key={`${keyTrackFn(item)}-${no}`}
            role={no === 0 ? undefined : "presentation"}
            aria-hidden={no === 0 ? undefined : true}
            className="logo-slide__carouselSlide"
            style={{
              marginLeft: `${spacing / 2}px`,
              marginRight: `${spacing / 2}px`,
            }}
          >
            {renderItem(item, height)}
          </li>
        ))}
      </ul>
      <div
        className="logo-slide__mask logo-slide__mask--right"
        style={{ width: `${height - 1}px` }}
      />
    </div>
  );
}

function renderItem(item: Item, size: number) {
  switch (item.type) {
    case "image":
      return (
        <img
          src={item.src}
          srcSet={item.srcSet}
          alt={item.alt}
          width={item.width}
          height={item.height ?? size}
        />
      );
    case "icon":
      return (
        <Icon name={item.name} color={item.color} size={size} alt={item.alt} />
      );
  }
}

function getTotalWidth(items: Item[], spacing: number, size: number) {
  const allSpacing = spacing * items.length;
  const allItems = items.reduce((sum, item) => {
    switch (item.type) {
      case "image":
        return sum + item.width;
      case "icon":
        return sum + size;
    }
  }, 0);

  return allItems + allSpacing;
}

function multiplyItems(items: Item[], multiplyCount: number) {
  const itemCount = items.length;

  return new Array(multiplyCount * itemCount)
    .fill(null)
    .map((_, x) => x)
    .map(
      (index) =>
        ({
          no: Math.floor(index / itemCount),
          item: items[index % itemCount],
        } as const)
    );
}
