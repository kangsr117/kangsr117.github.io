import * as React from "react";
import {
  createContext,
  DependencyList,
  EffectCallback,
  ReactElement,
  ReactNode,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react";
import { createPortal } from "react-dom";
import { animated, useSpring } from "react-spring";
import { isBrowser } from "../utils/isBrowser";

export const MagnifierContext = createContext<HTMLDivElement | null>(null);

interface MagnifierProviderProps {
  children: ReactElement;
}

export function MagnifierProvider({ children }: MagnifierProviderProps) {
  const [magnifierLayer, setMagnifierLayer] = useState<HTMLDivElement | null>(
    null
  );

  if (typeof window === "undefined") {
    return children;
  }

  const { fontA11y, fontScale } = { fontA11y: undefined, fontScale: undefined };

  // 앱 바깥인 경우 핀치 줌으로 확대가 가능하므로 필요가 없다.
  if (fontScale === undefined && fontA11y === undefined) {
    return children;
  }

  // 안드로이드인 경우 FontScale이 130 미만이면 사용하지 않는다.
  if (fontScale !== undefined && fontScale < 130) {
    return children;
  }

  // iOS의 경우 A11y_Medium 미만의 폰트 접근성 설정에서는 사용하지 않는다.
  // if (
  // fontA11y !== undefined &&
  // isSmallerFont(fontA11y, IOSFontA11yStyle.A11y_Medium)
  // ) {
  //   return children;
  // }

  return (
    <MagnifierContext.Provider value={magnifierLayer}>
      {children}
      <div
        id="magnifier-layer"
        ref={(elem) => {
          if (magnifierLayer != null || elem === null) {
            return;
          }

          setMagnifierLayer(elem);
        }}
      />
    </MagnifierContext.Provider>
  );
}

interface MagnifierConsumerProps {
  visible: boolean;
  children: ReactNode;
}

export function MagnifierConsumer({
  visible: shouldBeVisible,
  children,
}: MagnifierConsumerProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [isRest, setIsRest] = useState(true);
  const magnifierLayer = useContext(MagnifierContext);

  const { opacity } = useSpring({
    opacity: isVisible ? 1 : 0,
    delay: 200,
    onRest: () => {
      setIsRest(true);
    },
  });

  useDidUpdate(() => {
    setIsVisible(shouldBeVisible);
  }, [shouldBeVisible]);

  useDidUpdate(() => {
    setIsRest(false);
  }, [isVisible]);

  if (magnifierLayer == null || !isBrowser()) {
    return null;
  }

  if (isRest && !shouldBeVisible) {
    return null;
  }

  return createPortal(
    <animated.div
      style={{
        opacity,
      }}
    >
      {children}
    </animated.div>,
    magnifierLayer
  );
}

// function isSmallerFont(a: IOSFontA11yStyle, b: IOSFontA11yStyle) {
//   return fontSizeMap[a][0] < fontSizeMap[b][0];
// }

function useDidUpdate(effect: EffectCallback, deps: DependencyList) {
  const isMounted = useRef(false);

  useEffect(() => {
    if (isMounted.current) {
      return effect();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  useEffect(() => {
    isMounted.current = true;
  }, []);
}
