import { useCallback, useRef, useState } from 'react';

export interface UseControlledProps<T> {
  controlledValue?: T;
  defaultValue: T;
}

export default function useControlled<T = unknown>({
  controlledValue,
  defaultValue,
}: UseControlledProps<T>): [T, (newValue: T) => void] {
  const { current: isControlled } = useRef(controlledValue !== undefined);
  const [valueState, setValue] = useState(defaultValue);
  const value = isControlled ? controlledValue! : valueState;

  // TODO(cherry-style): 컴포넌트 생성 이후에 uncontrolled 방식과 controlled 방식을 dynamic하게 넘나드는 경우는 금지된다.
  // 개발자가 인지할 수 있게 개발 환경에서 assertion 혹은 error 로그를 추가한다

  const setValueIfUncontrolled = useCallback(
    (newValue: T) => {
      if (!isControlled) {
        setValue(newValue);
      }
    },
    // isControlled 는 변경되는 경우가 없기 때문에 hook dependency list에서 제외한다
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );

  return [value, setValueIfUncontrolled];
}
